Using a Spring app to drive your Cuke tests:

The Cuke runner:

@RunWith(Cucumber.class)
@CucumberOptions(plugin = {
        "html:target/cucumber-test-report",
        "json:target/cucumber-test-report.json",
        "pretty:target/cucumber-test-pretty.txt",
        "junit:target/cucumber-test-result.xml"},
        monochrome = true,
        features = "src/test/resources",
        glue = {"classpath:com.sample.qa"},
        tags = {"@Regression"}
)
public class ApiLoaderTestRunner {
}


The Spring application:

@EnableDiscoveryClient
@SpringBootApplication
@EnableRetry
public class QAApplication {
    public static void main(String[] args) {
        new SpringApplicationBuilder(QAApplication.class).web(WebApplicationType.NONE).run(args);
    }
}


The glue code:

@ContextConfiguration(classes = QAApplication.class, loader = SpringBootContextLoader.class)
public class ApiLoaderAutomationStepDefinitions {
@Before
public void setUp(final Scenario scenario) throws IOException {
    if (!environmentSetupHelper.isSetup()) {
        initialSetup();
    }
    this.scenario = scenario;
    scenarioData = ScenarioData.getInstance();
    clearDirectory();
}


And in ApiLoaderAutomationStepDefinitions, define:

@When("^the loader has been started$")
public void loaderIsBeingStarted() throws CustomException, IOException {
    stepImplementation.validateApiLoad();
}


********************************************************************************


Waiting for an event: rather than a Thread.sleep() with a static number of milliseconds,
use compile "org.awaitility:awaitility:4.0.1" as waiting times can significantly
vary depending on where you run the code (locally, on jenkins, etc.).

boolean checkEntityHasBeenCreated(final EntityParams entityParams) throws JsonProcessingException {
    final String entityCode = entityParams.getCode();
    final boolean result = fetchEntityResourceId(entityParams);
    if (result) {
        LOGGER.info("Entity Resource Details successfully fetched for entityCode {}", entityCode);
        scenario.write(format("Entity Resource Details successfully fetched for entityCode %s \n", entityCode));
    }
    return result;
}

with

private void verifyTheLoaderHasFinishedProcessing(final EntityParams entityParams) {
    LOGGER.info("Starting to wait: ");
    await().atMost(ofMinutes(5))
            .with()
            .pollInterval(ofSeconds(30))
            .until(() -> checkEntityHasBeenCreated(entityParams));
    LOGGER.info("Finished waiting.");
}

where

import static java.time.Duration.ofSeconds;
import static java.time.Duration.ofMinutes;


********************************************************************************


Cuke test with DataTable:

Feature file:

Then the entity is available in the database
  | entityCode  | entityDescription         | entityIndustryCode  | entityIndustryDescription |
  | 1111        | QA Test Eden              | 11                  | QA Test Industry Eden     |


Glue code (in package com.sample.qa.steps : see that it is important below with DataTableConfigurer) :

@Then("^the entity is available in the database$")
public void entityShouldGetCreated(final DataTable dataTable) throws JsonProcessingException {
    final List<EntityParams> entityParamsList = dataTable.asList(EntityParams.class);
    stepImplementation.checkEntityHasBeenCreated(entityParamsList.get(0));
}

Where

public class EntityParams {
      private String entityCode;
      private String entityDescription;
      private String entityIndustryCode;
      private String entityIndustryDescription;


And you also need the class below in the right package (it will be picked up automatically):
package com.sample.qa.steps;

import com.sample.qa.domain.EntityParams;
import com.fasterxml.jackson.databind.ObjectMapper;
import cucumber.api.TypeRegistry;
import cucumber.api.TypeRegistryConfigurer;
import io.cucumber.datatable.DataTableType;

import java.util.Locale;
import java.util.Map;

import static java.util.Locale.ENGLISH;

public class DataTableConfigurer implements TypeRegistryConfigurer {
      @Override
      public Locale locale() {
        return ENGLISH;
      }

      @Override
      public void configureTypeRegistry(TypeRegistry typeRegistry) {
        ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();

        typeRegistry.defineDataTableType(new DataTableType(
            EntityParams.class,
            (Map<String, String> row) -> objectMapper.convertValue(row, EntityParams.class))
        );
      }
}


********************************************************************************


IntelliJ Run Config:

Create a JUnit Run Config with:
    - name = QARunner
    - Class = com.sample.runner.TestRunner (which is under the qa_main module)
    - VM options = -ea -Dcucumber.options="--tags @TESTPB" -DuseProxy=true -Djavax.net.ssl.trustStore=src/test/resources/cacerts -Dspring.profiles.active=devint5 -Deureka.username=devintuser -Deureka.password=development
    - Use classpath pf module = qa_main
    - Shorten cmd line = JAR manifest

where

package com.sample.qa.automation.runner;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(features = {"src/test/resources/features/parallelRun"},
        glue = {"com.sample.qa.automation.steps"},
        plugin = {"html:target/cucumber-html-report", "json:target/cucumber.json",
                "pretty:target/cucumber-pretty.txt", "junit:target/cucumber-results.xml"})
public class TestRunner {
}


********************************************************************************


Rather than using a String in your step definitions, you can use an Enum.

You will need to define the link between the String ‘SampleApp.Create’ given in the feature file and the Enum with the below:

package com.sample.steps;

import io.cucumber.java.ParameterType;
import com.sample.steps.types.AppRole;
import com.sample.steps.types.ResponseType;

public class Types {
    @ParameterType(".*")
    public AppRole appRole(String roleName) {
        AppRole role = AppRole.find(roleName);
        if (role == null) {
            throw new AssertionError("Role " + roleName + " is not recognised.");
        }
        return role;
    }

    @ParameterType(".*")
    public ResponseType responseType(String value) {
        ResponseType rt = ResponseType.valueOf(value.toUpperCase());
        if (rt == null) {
            throw new AssertionError("ResponseType " + value + " is not recognised");
        }
        return rt;
    }
}


In the Feature file, you would have:
Given a user with SampleApp.Create role


In the glue code, you would have:
@Given("a user with {appRole} role(s)")
public void validOAuthToken(AppRole appRole) {
    oAuthHelper.setActiveRole(appRole);
}

Where

@Getter
public enum AppRole {
    All("All"),
    None("None"),
    SampleApp_Read("SampleApp.Read"),
    SampleApp_Create("SampleApp.Create"),
    SampleApp_Update("SampleApp.Update");

    private final String roleName;

    private AppRole(String roleName) {
        this.roleName = roleName;
    }

    public static AppRole find(String roleName) {
        for (AppRole role : AppRole.values()) {
            if (roleName.toLowerCase().equals(role.getRoleName().toLowerCase())) {
                return role;
            }
        }
        return null;
    }
}
