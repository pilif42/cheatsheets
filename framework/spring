- Pb to solve: in the class IINClientRepositoryImpl (which is a @Component), we want to auto-wire a RestTemplate and qualify it with a name (as it
 can only be one of the 2 beans that we configure using @ConditionalOnProperty below â€“ we do NOT want any other RestTemplate and also if they
 were other RestTemplates in the container and we did not qualify ours, then Spring would throw an exception saying it can not decide which bean
 to choose for the auto-wiring)


In IINCacheConfig (which is a @Configuration), we have:
@Bean(name = "iinServiceRestTemplate")
@IINServiceRestTemplateType("noEureka")
@ConditionalOnProperty(name = "iincache.service-registry.enabled", havingValue = "false")
public RestTemplate restTemplate() {
    return new RestTemplateBuilder().rootUri(iinDataServiceAPIUrl)
            .errorHandler(new DefaultResponseErrorHandler())
            .interceptors(Arrays.asList(new LoggingClientHttpRequestInterceptor()))
            .build();
}

@Bean(name = "iinServiceRestTemplate")
@LoadBalanced
@IINServiceRestTemplateType("viaEureka")
@ConditionalOnProperty(name = "iincache.service-registry.enabled", havingValue = "true")
public RestTemplate eurekaRestTemplate(@Value("${iincache.service-registry.username:#{null}}") String eurekaUsername,
  @Value("${iincache.service-registry.pass:#{null}}") String eurekaPassword) {
    List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
    interceptors.add(new LoggingClientHttpRequestInterceptor());
    if (eurekaUsername == null || eurekaPassword == null) {
        LOGGER.info("Eureka credentials not provided - basic authentication is not used");
    } else {
        LOGGER.info("Eureka credentials provided - basic authentication is used");
        interceptors.add(new BasicAuthorizationInterceptor(eurekaUsername, eurekaPassword));
    }

    return new RestTemplateBuilder().rootUri(String.format(SERVICE_NAME_PREFIX, iinDataServiceAPIName))
            .errorHandler(new DefaultResponseErrorHandler() {
                @Override
                public boolean hasError(ClientHttpResponse response) throws IOException {
                    return super.hasError(response) && (response.getStatusCode().series() != HttpStatus.Series.CLIENT_ERROR);
                }
            })
            .interceptors(interceptors)
            .build();
}


Where

@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface IINServiceRestTemplateType {
    String value() default "";
}


And in IINClientRepositoryImpl:
@Autowired @Qualifier("iinServiceRestTemplate")
private transient RestTemplate restTemplate;


- The problem: we want to load the IINCache at startup. It involves a call using a RestTemplate annotated with @LoadBalanced (which makes use of
 Ribbon). Spring does not recommend use of Ribbon during startup. We tried (the load was done inside the constructor of the autowired
 MetaDataCacheService) and it was failing as not all the Eureka-related artifacts were ready for use.

Solution 1: do not do the loading at startup (move the loading out of the constructor into a separate public method). Instead, load the cache
when it is first used. If however the initial load takes a long time (ie several minutes), favour solution 2.

Solution 2: do the loading right at the end of the startup thanks to the below that you add to a @Configuration class

@Bean
public ApplicationListener<SpringApplicationEvent> applicationListener(MetaDataCacheService metaDataCacheService) {
    return new ApplicationListener<SpringApplicationEvent>() {
        @Override
       public void onApplicationEvent(SpringApplicationEvent event) {
            if (event instanceof ApplicationReadyEvent) {
                metaDataCacheService.setup();
            }
        }
    };
}


- Problem: circuit-breaking with Hystrix

To add to build.gradle:
compile "org.springframework.cloud:spring-cloud-starter-hystrix"
compile "org.springframework.cloud:spring-cloud-starter-hystrix-dashboard"


On the main application:
@EnableCircuitBreaker
@EnableHystrixDashboard


In application.properties, add sth similar to. More details on Hystrix configuration can be found at https://github.com/Netflix/Hystrix/wiki/Configuration
hystrix:
  command:
    default:
      circuitBreaker:
        requestVolumeThreshold: 5
        sleepWindowInMilliseconds: 10000
      metrics.rollingStats.timeInMilliseconds: 20000
      execution.isolation:
        thread.timeoutInMilliseconds: 1000
        semaphore.maxConcurrentRequests: 10
    getPartyExtendedProfile:
      circuitBreaker:
        requestVolumeThreshold: 5
        sleepWindowInMilliseconds: 10000
      metrics.rollingStats.timeInMilliseconds: 20000
      execution.isolation:
        thread.timeoutInMilliseconds: 1000
        semaphore.maxConcurrentRequests: 10


In the Java code, where you do the REST call:
@HystrixCommand(commandKey = "updatePartyCoreProfile",
        commandProperties = {
                @HystrixProperty(name = "fallback.enabled", value = "false"),
                @HystrixProperty(name = "execution.isolation.strategy", value = "SEMAPHORE")
        })
public void updatePartyCoreProfile(final PartyCoreProfile partyCoreProfile) {
    final Map<String, Object> params = singletonMap("partyExtRef", partyCoreProfile.getPartyExtRef());
    final HttpHeaders requestHeaders = new HttpHeaders();
    if (nonNull(partyCoreProfile.getUpdatedBy())) {
        requestHeaders.add("profileRef", partyCoreProfile.getUpdatedBy());
    }
    final HttpEntity<PartyCoreProfile> partyCoreProfileRequest = new HttpEntity<>(partyCoreProfile, requestHeaders);
    try {
        partyCoreProfileRestTemplate.put("/security/v1/party/{partyExtRef}",
                partyCoreProfileRequest,
                params);

    } catch (HttpClientErrorException | HttpServerErrorException e) {
        logRequestError("updatePartyCoreProfile", e, partyCoreProfile);
        throw e;
    }
}


To see the Hystrix dashboard for your application, open http://hostname:port/hystrix


- Spring Integration test with @Sql:

Annotate your test class with:
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {ApplicationTestConfig.class, ExpandHierarchyServiceImplTest.PartyHierarchyServiceTestConfig.class, JacksonAutoConfiguration.class})
@TestPropertySource(locations = "classpath:/application-test.yml")

Where:

@Configuration
@ComponentScan(basePackages = {"com.sample.partyhierarchy.service", "com.sample.partyhierarchy.repository", "com.sample.partyhierarchy.jpa", "com.sample.party.services.mappers"})
public static class PartyHierarchyServiceTestConfig {
}

And:

import ch.vorburger.exec.ManagedProcessException;
import ch.vorburger.mariadb4j.DB;
import ch.vorburger.mariadb4j.springframework.MariaDB4jSpringService;
...
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.DependsOn;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Lazy;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;
import java.sql.Driver;

@TestConfiguration
@EnableJpaRepositories(basePackageClasses = {PartyRepository.class, PartyHierarchyRepository.class, UserRepository.class, UserPartyRepository.class})
@EntityScan(basePackages = "com.sample.partyhierarchy.jpa")
@Import({DataSourceAutoConfiguration.class, JdbcTemplateAutoConfiguration.class, HibernateJpaAutoConfiguration.class})
public class ApplicationTestConfig {
    @Lazy
    private PartyRepository partyRepository;

    @Lazy
    private PartyHierarchyRepository partyHierarchyRepository;

    @Bean
    public MariaDB4jSpringService mariaDB4jSpringService() throws ManagedProcessException {
        return new MariaDB4jSpringService();
    }

    @Bean
    public DB db(@Autowired MariaDB4jSpringService mariaDB4jSpringService) throws ManagedProcessException {
        DB db = mariaDB4jSpringService.getDB();
        db.createDB("partyhierarchy");
        db.source("sql/party_hierarchy_initial_create.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_2.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_5.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_7.sql", "root", null, "partyhierarchy");

        return db;
    }

    @Bean
    @DependsOn("db")
    public DataSource dataSource(@Value("${spring.datasource.driver-class-name}") String dataSourceClassName,
                                 @Autowired MariaDB4jSpringService mariaDB4jSpringService,
                                 @Value("${spring.datasource.username}") String username) throws Exception {
        SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
        dataSource.setDriverClass((Class<Driver>) Class.forName(dataSourceClassName));
        dataSource.setUrl(mariaDB4jSpringService.getConfiguration().getURL("partyhierarchy"));
        dataSource.setUsername(username);

        return dataSource;
    }

    @Bean
    @DependsOn("dataSource")
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Autowired DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.sample.partyhierarchy");

        JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);

        return em;
    }

    @Bean
    public PlatformTransactionManager transactionManager(@Autowired EntityManagerFactory emf) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(emf);

        return transactionManager;
    }

    @Bean
    LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean();
    }
}

And annotate your test with:

@Test
@Sql("/partyHierarchy/sql/datasetX.sql")
@Sql(scripts = "/partyHierarchy/sql/deleteData.sql", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testAllHierarchiesDatasetX() throws Exception {


- Spring MVC Streaming:
Baeldung reference at https://www.baeldung.com/spring-mvc-sse-streams

@GetMapping("/expandRootNode")
public StreamingResponseBody expandAllRootNodes(@RequestAttribute(value = EFFECTIVE_DATE_HEADER, required = false) Date effDate) {
        log.info("Entering expandAllRootNodes");
        return out -> hierarchyService.expandAllRootNodes(out, effDate);
}

@GetMapping("")
public StreamingResponseBody getAllPartyHierarchies(@RequestParam(name = "externalIds", required = false) String externalIds,
        @RequestAttribute(value = EFFECTIVE_DATE_HEADER, required = false) Date effDate) {
        log.info("Entering getAllPartyHierarchies");
        if (!StringUtils.isBlank(externalIds)) {
            Set<String> externalIdSet = new HashSet<>(Arrays.asList(externalIds.split("\\s*,\\s*")));
            return out -> hierarchyService.getHierarchyByPartyExtRef(out, externalIdSet, effDate);
        }

        return hierarchyService::getAllPartyHierarchies;
}

Where the interface HierarchyService contains:
void expandAllRootNodes(OutputStream out, final Date effectiveDate) throws IOException;
void getAllPartyHierarchies(OutputStream out) throws IOException;


- To start a 2.0 Spring Boot app:
    - In GitBash:
          - build the .jar with mvn clean install
          - cd target
          - java -Dspring.profiles.active="local" -jar monetisation-service-0.0.1-SNAPSHOT.jar
    - In IntelliJ:
          - Run config with VM options: -Dspring.profiles.active="local"
          - or Maven window with 'm' icon: mvn clean spring-boot:run -Dspring-boot.run.arguments="--spring.profiles.active=local"


- To store an entity data across 2 tables: the entity is ErrorOmission. The tables are error_omission, error_omission_products (note the @ElementCollection on the Set<Product> products) and error_omission_access_types (note the @ElementCollection on the Set<AccessType>).
    - Schema defined in db.changelog-master.yaml through Liquibase:
          databaseChangeLog:
            - changeSet:
                id: 1
                author: pbross
                changes:
                  - createTable:
                      tableName: error_omission
                      columns:
                        - column:
                            name: error_reference
                            type: BIGINT
                            autoIncrement: true
                            constraints:
                              - primaryKey: true
                                nullable: false
                        - column:
                            name: developer_id
                            type: varchar(255)
                            constraints:
                              - nullable: false
                        - column:
                            name: correction_type
                            type: varchar(20)
                            constraints:
                              - nullable: false
                        - column:
                            name: other_product
                            type: varchar(255)
                            constraints:
                              - nullable: true
                        - column:
                            name: other_access_type
                            type: varchar(255)
                            constraints:
                              - nullable: true
                        - column:
                            name: title
                            type: varchar(255)
                        - column:
                            name: description
                            type: CLOB
                        - column:
                            name: impact
                            type: varchar(255)
                        - column:
                            name: geom
                            type: Geometry
                            constraints:
                              - nullable: true
                        - column:
                            name: location
                            type: Geometry
                            constraints:
                              - nullable: true
                        - column:
                            name: created
                            type: DATETIME
                            constraints:
                              - nullable: false

                  - createTable:
                      tableName: error_omission_products
                      columns:
                        - column:
                            name: error_omission_error_reference
                            type: BIGINT
                            constraints:
                              - foreignKeyName: fk_product_error_omission
                                references: error_omission(error_reference)
                                nullable: false
                        - column:
                            name: product
                            type: varchar(50)
                            constraints:
                              - nullable: false

                  - createTable:
                      tableName: error_omission_access_types
                      columns:
                        - column:
                            name: error_omission_error_reference
                            type: BIGINT
                            constraints:
                              - foreignKeyName: fk_access_types_error_omission
                                references: error_omission(error_reference)
                                nullable: false
                        - column:
                            name: access_type
                            type: varchar(20)
                            constraints:
                              - nullable: false

            - changeSet:
                id: 2
                author: pbross
                changes:
                  - sql:
                      dbms: mssql
                      splitStatements: true
                      sql: |
                        CREATE SPATIAL INDEX error_omission_geom_idx ON error_omission(geom) WITH ( BOUNDING_BOX = (-100000, 0, 700000, 1300000) );
                        CREATE SPATIAL INDEX error_omission_location_idx ON error_omission(location) WITH ( BOUNDING_BOX = (-100000, 0, 700000, 1300000) );
                  - sql:
                      dbms: h2
                      splitStatements: true
                      sql: |
                        CREATE SPATIAL INDEX error_omission_geom_idx ON error_omission(geom);
                        CREATE SPATIAL INDEX error_omission_location_idx ON error_omission(location);

    - Entity bean defined with:
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Point;

import javax.persistence.*;
import java.time.Instant;
import java.util.Set;

@Entity
@Getter
@Setter
@EntityListeners(ErrorOmissionEntityListener.class)
public class ErrorOmission {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long errorReference;

        private String developerId;

        @Enumerated(EnumType.STRING)
        private CorrectionType correctionType;

        @ElementCollection
        @Enumerated(EnumType.STRING)
        @Column(name = "product")
        private Set<Product> products;

        private String otherProduct;

        @ElementCollection
        @Enumerated(EnumType.STRING)
        @Column(name = "access_type")
        private Set<AccessType> accessTypes;

        private String otherAccessType;

        @Column(name = "geom")
        private Geometry geometry;

        private Point location;

        private String title;

        private String description;

        private String impact;

        @CreationTimestamp
        private Instant created;
}
