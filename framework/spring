- Pb to solve: in the class IINClientRepositoryImpl (which is a @Component), we want to auto-wire a RestTemplate and qualify it with a name (as it
 can only be one of the 2 beans that we configure using @ConditionalOnProperty below â€“ we do NOT want any other RestTemplate and also if they
 were other RestTemplates in the container and we did not qualify ours, then Spring would throw an exception saying it can not decide which bean
 to choose for the auto-wiring)


In IINCacheConfig (which is a @Configuration), we have:
@Bean(name = "iinServiceRestTemplate")
@IINServiceRestTemplateType("noEureka")
@ConditionalOnProperty(name = "iincache.service-registry.enabled", havingValue = "false")
public RestTemplate restTemplate() {
    return new RestTemplateBuilder().rootUri(iinDataServiceAPIUrl)
            .errorHandler(new DefaultResponseErrorHandler())
            .interceptors(Arrays.asList(new LoggingClientHttpRequestInterceptor()))
            .build();
}

@Bean(name = "iinServiceRestTemplate")
@LoadBalanced
@IINServiceRestTemplateType("viaEureka")
@ConditionalOnProperty(name = "iincache.service-registry.enabled", havingValue = "true")
public RestTemplate eurekaRestTemplate(@Value("${iincache.service-registry.username:#{null}}") String eurekaUsername,
  @Value("${iincache.service-registry.pass:#{null}}") String eurekaPassword) {
    List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>();
    interceptors.add(new LoggingClientHttpRequestInterceptor());
    if (eurekaUsername == null || eurekaPassword == null) {
        LOGGER.info("Eureka credentials not provided - basic authentication is not used");
    } else {
        LOGGER.info("Eureka credentials provided - basic authentication is used");
        interceptors.add(new BasicAuthorizationInterceptor(eurekaUsername, eurekaPassword));
    }

    return new RestTemplateBuilder().rootUri(String.format(SERVICE_NAME_PREFIX, iinDataServiceAPIName))
            .errorHandler(new DefaultResponseErrorHandler() {
                @Override
                public boolean hasError(ClientHttpResponse response) throws IOException {
                    return super.hasError(response) && (response.getStatusCode().series() != HttpStatus.Series.CLIENT_ERROR);
                }
            })
            .interceptors(interceptors)
            .build();
}


Where

@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface IINServiceRestTemplateType {
    String value() default "";
}


And in IINClientRepositoryImpl:
@Autowired @Qualifier("iinServiceRestTemplate")
private transient RestTemplate restTemplate;


- The problem: we want to load the IINCache at startup. It involves a call using a RestTemplate annotated with @LoadBalanced (which makes use of
 Ribbon). Spring does not recommend use of Ribbon during startup. We tried (the load was done inside the constructor of the autowired
 MetaDataCacheService) and it was failing as not all the Eureka-related artifacts were ready for use.

Solution 1: do not do the loading at startup (move the loading out of the constructor into a separate public method). Instead, load the cache
when it is first used. If however the initial load takes a long time (ie several minutes), favour solution 2.

Solution 2: do the loading right at the end of the startup thanks to the below that you add to a @Configuration class

@Bean
public ApplicationListener<SpringApplicationEvent> applicationListener(MetaDataCacheService metaDataCacheService) {
    return new ApplicationListener<SpringApplicationEvent>() {
        @Override
       public void onApplicationEvent(SpringApplicationEvent event) {
            if (event instanceof ApplicationReadyEvent) {
                metaDataCacheService.setup();
            }
        }
    };
}


- Problem: circuit-breaking with Hystrix

To add to build.gradle:
compile "org.springframework.cloud:spring-cloud-starter-hystrix"
compile "org.springframework.cloud:spring-cloud-starter-hystrix-dashboard"


On the main application:
@EnableCircuitBreaker
@EnableHystrixDashboard


In application.properties, add sth similar to. More details on Hystrix configuration can be found at https://github.com/Netflix/Hystrix/wiki/Configuration
hystrix:
  command:
    default:
      circuitBreaker:
        requestVolumeThreshold: 5
        sleepWindowInMilliseconds: 10000
      metrics.rollingStats.timeInMilliseconds: 20000
      execution.isolation:
        thread.timeoutInMilliseconds: 1000
        semaphore.maxConcurrentRequests: 10
    getPartyExtendedProfile:
      circuitBreaker:
        requestVolumeThreshold: 5
        sleepWindowInMilliseconds: 10000
      metrics.rollingStats.timeInMilliseconds: 20000
      execution.isolation:
        thread.timeoutInMilliseconds: 1000
        semaphore.maxConcurrentRequests: 10


In the Java code, where you do the REST call:
@HystrixCommand(commandKey = "updatePartyCoreProfile",
        commandProperties = {
                @HystrixProperty(name = "fallback.enabled", value = "false"),
                @HystrixProperty(name = "execution.isolation.strategy", value = "SEMAPHORE")
        })
public void updatePartyCoreProfile(final PartyCoreProfile partyCoreProfile) {
    final Map<String, Object> params = singletonMap("partyExtRef", partyCoreProfile.getPartyExtRef());
    final HttpHeaders requestHeaders = new HttpHeaders();
    if (nonNull(partyCoreProfile.getUpdatedBy())) {
        requestHeaders.add("profileRef", partyCoreProfile.getUpdatedBy());
    }
    final HttpEntity<PartyCoreProfile> partyCoreProfileRequest = new HttpEntity<>(partyCoreProfile, requestHeaders);
    try {
        partyCoreProfileRestTemplate.put("/security/v1/party/{partyExtRef}",
                partyCoreProfileRequest,
                params);

    } catch (HttpClientErrorException | HttpServerErrorException e) {
        logRequestError("updatePartyCoreProfile", e, partyCoreProfile);
        throw e;
    }
}


To see the Hystrix dashboard for your application, open http://hostname:port/hystrix


- Spring Integration test with @Sql:

Annotate your test class with:
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {ApplicationTestConfig.class, ExpandHierarchyServiceImplTest.PartyHierarchyServiceTestConfig.class, JacksonAutoConfiguration.class})
@TestPropertySource(locations = "classpath:/application-test.yml")

Where:

@Configuration
@ComponentScan(basePackages = {"com.sample.partyhierarchy.service", "com.sample.partyhierarchy.repository", "com.sample.partyhierarchy.jpa", "com.sample.party.services.mappers"})
public static class PartyHierarchyServiceTestConfig {
}

And:

import ch.vorburger.exec.ManagedProcessException;
import ch.vorburger.mariadb4j.DB;
import ch.vorburger.mariadb4j.springframework.MariaDB4jSpringService;
...
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.DependsOn;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Lazy;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;
import java.sql.Driver;

@TestConfiguration
@EnableJpaRepositories(basePackageClasses = {PartyRepository.class, PartyHierarchyRepository.class, UserRepository.class, UserPartyRepository.class})
@EntityScan(basePackages = "com.sample.partyhierarchy.jpa")
@Import({DataSourceAutoConfiguration.class, JdbcTemplateAutoConfiguration.class, HibernateJpaAutoConfiguration.class})
public class ApplicationTestConfig {
    @Lazy
    private PartyRepository partyRepository;

    @Lazy
    private PartyHierarchyRepository partyHierarchyRepository;

    @Bean
    public MariaDB4jSpringService mariaDB4jSpringService() throws ManagedProcessException {
        return new MariaDB4jSpringService();
    }

    @Bean
    public DB db(@Autowired MariaDB4jSpringService mariaDB4jSpringService) throws ManagedProcessException {
        DB db = mariaDB4jSpringService.getDB();
        db.createDB("partyhierarchy");
        db.source("sql/party_hierarchy_initial_create.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_2.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_5.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_7.sql", "root", null, "partyhierarchy");

        return db;
    }

    @Bean
    @DependsOn("db")
    public DataSource dataSource(@Value("${spring.datasource.driver-class-name}") String dataSourceClassName,
                                 @Autowired MariaDB4jSpringService mariaDB4jSpringService,
                                 @Value("${spring.datasource.username}") String username) throws Exception {
        SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
        dataSource.setDriverClass((Class<Driver>) Class.forName(dataSourceClassName));
        dataSource.setUrl(mariaDB4jSpringService.getConfiguration().getURL("partyhierarchy"));
        dataSource.setUsername(username);

        return dataSource;
    }

    @Bean
    @DependsOn("dataSource")
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Autowired DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.sample.partyhierarchy");

        JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);

        return em;
    }

    @Bean
    public PlatformTransactionManager transactionManager(@Autowired EntityManagerFactory emf) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(emf);

        return transactionManager;
    }

    @Bean
    LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean();
    }
}

And annotate your test with:

@Test
@Sql("/partyHierarchy/sql/datasetX.sql")
@Sql(scripts = "/partyHierarchy/sql/deleteData.sql", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testAllHierarchiesDatasetX() throws Exception {


- Spring MVC Streaming:
Baeldung reference at https://www.baeldung.com/spring-mvc-sse-streams

@GetMapping("/expandRootNode")
public StreamingResponseBody expandAllRootNodes(@RequestAttribute(value = EFFECTIVE_DATE_HEADER, required = false) Date effDate) {
        log.info("Entering expandAllRootNodes");
        return out -> hierarchyService.expandAllRootNodes(out, effDate);
}

@GetMapping("")
public StreamingResponseBody getAllPartyHierarchies(@RequestParam(name = "externalIds", required = false) String externalIds,
        @RequestAttribute(value = EFFECTIVE_DATE_HEADER, required = false) Date effDate) {
        log.info("Entering getAllPartyHierarchies");
        if (!StringUtils.isBlank(externalIds)) {
            Set<String> externalIdSet = new HashSet<>(Arrays.asList(externalIds.split("\\s*,\\s*")));
            return out -> hierarchyService.getHierarchyByPartyExtRef(out, externalIdSet, effDate);
        }

        return hierarchyService::getAllPartyHierarchies;
}

Where the interface HierarchyService contains:
void expandAllRootNodes(OutputStream out, final Date effectiveDate) throws IOException;
void getAllPartyHierarchies(OutputStream out) throws IOException;


- To start a 2.0 Spring Boot app:
    - In GitBash:
          - build the .jar with mvn clean install
          - cd target
          - java -Dspring.profiles.active="local" -jar monetisation-service-0.0.1-SNAPSHOT.jar
    - In IntelliJ:
          - Run config with VM options: -Dspring.profiles.active="local"
          - or Maven window with 'm' icon: mvn clean spring-boot:run -Dspring-boot.run.arguments="--spring.profiles.active=local"
