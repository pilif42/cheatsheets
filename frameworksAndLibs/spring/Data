- Spring Integration test with @Sql:

Annotate your test class with:
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {ApplicationTestConfig.class, ExpandHierarchyServiceImplTest.PartyHierarchyServiceTestConfig.class, JacksonAutoConfiguration.class})
@TestPropertySource(locations = "classpath:/application-test.yml")

Where:

@Configuration
@ComponentScan(basePackages = {"com.sample.partyhierarchy.service", "com.sample.partyhierarchy.repository", "com.sample.partyhierarchy.jpa", "com.sample.party.services.mappers"})
public static class PartyHierarchyServiceTestConfig {
}

And:

import ch.vorburger.exec.ManagedProcessException;
import ch.vorburger.mariadb4j.DB;
import ch.vorburger.mariadb4j.springframework.MariaDB4jSpringService;
...
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.DependsOn;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Lazy;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;
import java.sql.Driver;

@TestConfiguration
@EnableJpaRepositories(basePackageClasses = {PartyRepository.class, PartyHierarchyRepository.class, UserRepository.class, UserPartyRepository.class})
@EntityScan(basePackages = "com.sample.partyhierarchy.jpa")
@Import({DataSourceAutoConfiguration.class, JdbcTemplateAutoConfiguration.class, HibernateJpaAutoConfiguration.class})
public class ApplicationTestConfig {
    @Lazy
    private PartyRepository partyRepository;

    @Lazy
    private PartyHierarchyRepository partyHierarchyRepository;

    @Bean
    public MariaDB4jSpringService mariaDB4jSpringService() throws ManagedProcessException {
        return new MariaDB4jSpringService();
    }

    @Bean
    public DB db(@Autowired MariaDB4jSpringService mariaDB4jSpringService) throws ManagedProcessException {
        DB db = mariaDB4jSpringService.getDB();
        db.createDB("partyhierarchy");
        db.source("sql/party_hierarchy_initial_create.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_2.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_5.sql", "root", null, "partyhierarchy");
        db.source("sql/schema_update_7.sql", "root", null, "partyhierarchy");

        return db;
    }

    @Bean
    @DependsOn("db")
    public DataSource dataSource(@Value("${spring.datasource.driver-class-name}") String dataSourceClassName,
                                 @Autowired MariaDB4jSpringService mariaDB4jSpringService,
                                 @Value("${spring.datasource.username}") String username) throws Exception {
        SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
        dataSource.setDriverClass((Class<Driver>) Class.forName(dataSourceClassName));
        dataSource.setUrl(mariaDB4jSpringService.getConfiguration().getURL("partyhierarchy"));
        dataSource.setUsername(username);

        return dataSource;
    }

    @Bean
    @DependsOn("dataSource")
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Autowired DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.sample.partyhierarchy");

        JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);

        return em;
    }

    @Bean
    public PlatformTransactionManager transactionManager(@Autowired EntityManagerFactory emf) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(emf);

        return transactionManager;
    }

    @Bean
    LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean();
    }
}

And annotate your test with:

@Test
@Sql("/partyHierarchy/sql/datasetX.sql")
@Sql(scripts = "/partyHierarchy/sql/deleteData.sql", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testAllHierarchiesDatasetX() throws Exception {


- To store an entity data across 2 tables: the entity is ErrorOmission. The tables are error_omission, error_omission_products (note the @ElementCollection on the Set<Product> products) and error_omission_access_types (note the @ElementCollection on the Set<AccessType>).
    - Schema defined in db.changelog-master.yaml through Liquibase:
          databaseChangeLog:
            - changeSet:
                id: 1
                author: pbross
                changes:
                  - createTable:
                      tableName: error_omission
                      columns:
                        - column:
                            name: error_reference
                            type: BIGINT
                            autoIncrement: true
                            constraints:
                              - primaryKey: true
                                nullable: false
                        - column:
                            name: developer_id
                            type: varchar(255)
                            constraints:
                              - nullable: false
                        - column:
                            name: correction_type
                            type: varchar(20)
                            constraints:
                              - nullable: false
                        - column:
                            name: other_product
                            type: varchar(255)
                            constraints:
                              - nullable: true
                        - column:
                            name: other_access_type
                            type: varchar(255)
                            constraints:
                              - nullable: true
                        - column:
                            name: title
                            type: varchar(255)
                        - column:
                            name: description
                            type: CLOB
                        - column:
                            name: impact
                            type: varchar(255)
                        - column:
                            name: geom
                            type: Geometry
                            constraints:
                              - nullable: true
                        - column:
                            name: location
                            type: Geometry
                            constraints:
                              - nullable: true
                        - column:
                            name: created
                            type: DATETIME
                            constraints:
                              - nullable: false

                  - createTable:
                      tableName: error_omission_products
                      columns:
                        - column:
                            name: error_omission_error_reference
                            type: BIGINT
                            constraints:
                              - foreignKeyName: fk_product_error_omission
                                references: error_omission(error_reference)
                                nullable: false
                        - column:
                            name: product
                            type: varchar(50)
                            constraints:
                              - nullable: false

                  - createTable:
                      tableName: error_omission_access_types
                      columns:
                        - column:
                            name: error_omission_error_reference
                            type: BIGINT
                            constraints:
                              - foreignKeyName: fk_access_types_error_omission
                                references: error_omission(error_reference)
                                nullable: false
                        - column:
                            name: access_type
                            type: varchar(20)
                            constraints:
                              - nullable: false

            - changeSet:
                id: 2
                author: pbross
                changes:
                  - sql:
                      dbms: mssql
                      splitStatements: true
                      sql: |
                        CREATE SPATIAL INDEX error_omission_geom_idx ON error_omission(geom) WITH ( BOUNDING_BOX = (-100000, 0, 700000, 1300000) );
                        CREATE SPATIAL INDEX error_omission_location_idx ON error_omission(location) WITH ( BOUNDING_BOX = (-100000, 0, 700000, 1300000) );
                  - sql:
                      dbms: h2
                      splitStatements: true
                      sql: |
                        CREATE SPATIAL INDEX error_omission_geom_idx ON error_omission(geom);
                        CREATE SPATIAL INDEX error_omission_location_idx ON error_omission(location);

    - Entity bean defined with:
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Point;

import javax.persistence.*;
import java.time.Instant;
import java.util.Set;

@Entity
@Getter
@Setter
@EntityListeners(ErrorOmissionEntityListener.class)
public class ErrorOmission {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long errorReference;

        private String developerId;

        @Enumerated(EnumType.STRING)
        private CorrectionType correctionType;

        @ElementCollection
        @Enumerated(EnumType.STRING)
        @Column(name = "product")
        private Set<Product> products;

        private String otherProduct;

        @ElementCollection
        @Enumerated(EnumType.STRING)
        @Column(name = "access_type")
        private Set<AccessType> accessTypes;

        private String otherAccessType;

        @Column(name = "geom")
        private Geometry geometry;

        private Point location;

        private String title;

        private String description;

        private String impact;

        @CreationTimestamp
        private Instant created;
}


Note the importance of @Enumerated(EnumType.STRING) on Enum fields part of the
Entity and that need to be stored as a String. If you forget it, Spring JPA will
assume that it is an Integer for some reasons. On storing to the DB, it will be
OK. However, when fetching from the DB, you will encounter some NumberFormatExceptions.


- Example with @Embeddable:

The main Entity is:

package com.sample.errorsandomissions.entity;

import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Point;

import javax.persistence.*;
import java.time.Instant;
import java.util.Collections;
import java.util.Set;

@Entity
@Getter
@Setter
@EntityListeners(ErrorOmissionEntityListener.class)
public class ErrorOmission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long errorReference;

    private String developerId;

    @ElementCollection
    @Enumerated(EnumType.STRING)
    @Column(name = "product")
    private Set<Product> products;

    @Column(name = "geom")
    private Geometry geometry;

    private Point location;

    @ElementCollection
    private Set<StatusChange> statusHistory;

    @PrePersist
    public void onCreate() {
        StatusChange statusChange = new StatusChange();
        statusChange.setStatus(Status.SUBMITTED);
        /**
         * TODO When https://hibernate.atlassian.net/browse/HHH-13829 is fixed, use instead @CreationTimestamp on
         * TODO changed in StatusChange.
         */
        statusChange.setChanged(Instant.now());
        statusHistory = Collections.singleton(statusChange);
   }
}


The embedded Entity is:
package com.sample.errorsandomissions.entity;

import lombok.Getter;
import lombok.Setter;

import javax.persistence.Embeddable;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import java.time.Instant;

@Embeddable
@Getter
@Setter
public class StatusChange {
    @Enumerated(EnumType.STRING)
    private Status status;

    private String resolution;

    private Instant changed;
}


The Liquibase change set is:

- changeSet:
    id: 7
    author: jdoe
    changes:
      - createTable:
          tableName: error_omission_status_history
          columns:
            - column:
                name: error_omission_error_reference
                type: BIGINT
                constraints:
                  - foreignKeyName: fk_status_details_error_omission
                    references: error_omission(error_reference)
                    nullable: false
            - column:
                name: status
                type: varchar(20)
                defaultValue: SUBMITTED
                constraints:
                  - nullable: false
            - column:
                name: resolution
                type: varchar(255)
            - column:
                name: changed
                type: DATETIME
                constraints:
                  - nullable: false


- Spring Integration test for a Repository class:
See https://reflectoring.io/spring-boot-data-jpa-test/ for a full tutorial. It was used to put together the test below:

package sample.com.repository;

import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.locationtech.jts.geom.GeometryFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;
import sample.com.LocationCalculator;
import sample.com.entity.ErrorOmission;
import sample.com.entity.Product;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static sample.com.util.DataUtil.buildErrorOmission;

@DataJpaTest
@ActiveProfiles("local,h2")
public class ErrorOmissionRepositoryTest {

    @Autowired
    private ErrorOmissionRepository errorOmissionRepository;

    @MockBean
    private LocationCalculator locationCalculator;

   @MockBean
    private GeometryFactory geometryFactory;

    @Test
    void getErrorOmissionsToBeRepaired_emptyDatabase_thenEmptyResultList() {
        Instant instantEnd = Instant.now();
        List<ErrorOmission> resultList = errorOmissionRepository.getErrorOmissionsToBeRepaired(instantEnd.minus(7, ChronoUnit.DAYS), instantEnd);
        assertTrue(resultList.isEmpty());
    }

    @Test
    void getErrorOmissionsToBeRepaired_oneErrorLinkedToACaseStored_thenEmptyResultList() {
       ErrorOmission errorOmission = buildErrorOmission() ;
        errorOmission.setCaseId("someCaseId");
        errorOmissionRepository.save(errorOmission);

        Instant instantEnd = Instant.now();
        List<ErrorOmission> resultList = errorOmissionRepository.getErrorOmissionsToBeRepaired(instantEnd.minus(7, ChronoUnit.DAYS), instantEnd);
        assertTrue(resultList.isEmpty());
    }
}

where application-local.properties contains: spring.jpa.show-sql=true

where application-h2.properties contains: spring.jpa.properties.hibernate.dialect=org.hibernate.spatial.dialect.h2geodb.GeoDBDialect


- To solve org.hibernate.LazyInitializationException at start up:
When starting our Spring Boot app, we were getting the following exception:
Caused by: org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.sample.entity.ErrorOmission.products, could not initialize proxy - no Session
               at org.hibernate.collection.internal.AbstractPersistentCollection.throwLazyInitializationException(AbstractPersistentCollection.java:606)
               at org.hibernate.collection.internal.AbstractPersistentCollection.withTemporarySessionIfNeeded(AbstractPersistentCollection.java:218)
               at org.hibernate.collection.internal.AbstractPersistentCollection.readSize(AbstractPersistentCollection.java:162)
               at org.hibernate.collection.internal.PersistentSet.isEmpty(PersistentSet.java:174)
               at org.springframework.util.CollectionUtils.isEmpty(CollectionUtils.java:54)
               at com.sample.util.MappingUtil.map(MappingUtil.java:40)
               at com.sample.service.BfinServiceImpl.createInternalIssue(BfinServiceImpl.java:43)

Where BfinServiceImpl.createInternalIssue was called in an asynch process:
@Async
@Override
public void startupRepair(long timestamp) {
    log.debug("Entering startupRepair...");
    Instant instantEnd = Instant.ofEpochMilli(timestamp);
    List<ErrorOmission> errorOmissionList = dbRetryTemplate.execute(context ->
            repository.getErrorOmissionsToBeRepaired(instantEnd.minus(7, ChronoUnit.DAYS), instantEnd));
    log.debug("Retrieved {} ErrorOmission(s) to be repaired", errorOmissionList.size());
    errorOmissionList.forEach(error -> errorOmissionService.update(error, bfinService.createInternalIssue(error)));
}

And this asynch process was triggered in:
@Component
public class EventListenerBean {
    private final BfinConfiguration bfinConfiguration;
    private final BfinRepairService bfinRepairService;

    public EventListenerBean(BfinConfiguration bfinConfiguration, BfinRepairService bfinRepairService) {
        this.bfinConfiguration = bfinConfiguration;
        this.bfinRepairService = bfinRepairService;
    }

    @EventListener
    public void onApplicationEvent(ContextRefreshedEvent event) {
        if (bfinConfiguration.isEnabled()) {
            bfinRepairService.startupRepair(event.getTimestamp());
        }
    }
}

Note that before createInternalIssue is called, we retrieve from the database the errors to be repaired.
When we were getting the exception, we were using repository.findAllErrorOmissionWhereCaseIdIsNull.

I fixed it first by adding eager fetching for the collection products on our ErrorAndOmission entity:
@ElementCollection(fetch = FetchType.EAGER)
@Enumerated(EnumType.STRING)
@Column(name = "product")
private Set<Product> products;

A better solution is to use a query on the repository:
@Query(value = "select e FROM ErrorOmission e left join fetch e.products where e.caseId is null and e.created between :instantStart and :instantEnd")
List<ErrorOmission> getErrorOmissionsToBeRepaired(Instant instantStart, Instant instantEnd);

The important thing to note is the ‘left’ before ‘join’. Without it, if an error does not have a product, it will not be
 returned in the result list.


- JPA native queries used when implementing a server-side clustering (pointing to a Microsoft SQL Server db):
@Profile("sqlserver")
public interface ErrorOmissionRepository extends PagingAndSortingRepository<ErrorOmission, Long>, JpaSpecificationExecutor<ErrorOmission> {
    ErrorOmission findByErrorReference(Long errorReference);

    @Query(value = "select * from error_omission e where location.STX = :x and location.STY = :y", nativeQuery = true)
    ErrorOmission getErrorOmission(double x, double y);

    /**
     * EandOs with a CLOSED status or a REJECTED resolution are filtered out.
     */
    @Query(value = "select count(1) numberOfIssues, (((geometry\\:\\:ConvexHullAggregate(location)).STBuffer(0.00001)).STCentroid()).STAsText() centre from error_omission where (status <> 'CLOSED' or resolution <> 'REJECTED') and location.STX >= :bottomLeftCornerX and location.STX <= :topRightCornerX and location.STY >= :bottomLeftCornerY and location.STY <= :topRightCornerY group by round(location.STX * :coordinateMultiplier, -4), round(location.STY * :coordinateMultiplier, -4)",
            nativeQuery = true)
    Set<Cluster> getClustersForAllDevelopers(double bottomLeftCornerX, double bottomLeftCornerY, double topRightCornerX, double topRightCornerY, double coordinateMultiplier);

    /**
     * EandOs with a CLOSED status or a REJECTED resolution are filtered out.
     */
    @Query(value = "select count(1) numberOfIssues, (((geometry\\:\\:ConvexHullAggregate(location)).STBuffer(0.00001)).STCentroid()).STAsText() centre, STRING_AGG(error_reference, ',') as errorRefs from (select error_reference, location from error_omission where error_reference in (SELECT error_reference FROM error_omission where (status <> 'CLOSED' or resolution <> 'REJECTED') and location.STX >= :bottomLeftCornerX and location.STX <= :topRightCornerX and location.STY >= :bottomLeftCornerY and location.STY <= :topRightCornerY)) AS displayableEandOs group by round(location.STX * :coordinateMultiplier,-4), round(location.STY * :coordinateMultiplier, -4)",
            nativeQuery = true)
    Set<Cluster> getClustersForAllDevelopersIncludingErrorRefs(double bottomLeftCornerX, double bottomLeftCornerY, double topRightCornerX, double topRightCornerY, double coordinateMultiplier);

    @Query(value = "select count(1) numberOfIssues, (((geometry\\:\\:ConvexHullAggregate(location)).STBuffer(0.00001)).STCentroid()).STAsText() centre, STRING_AGG(error_reference, ',') as errorRefs, SUM(my_error) numberOfIssuesOwnedByMe from (select error_reference, location, my_error = case when developer_id = :developerId then 1 else 0 end FROM error_omission where error_reference in (SELECT error_reference FROM error_omission where location.STX >= :bottomLeftCornerX and location.STX <= :topRightCornerX and location.STY >= :bottomLeftCornerY and location.STY <= :topRightCornerY and status <> 'CLOSED' and developer_id = :developerId UNION SELECT error_reference FROM error_omission where location.STX >= :bottomLeftCornerX and location.STX <= :topRightCornerX and location.STY >= :bottomLeftCornerY and location.STY <= :topRightCornerY and status not in ('SUBMITTED', 'CLOSED') and developer_id <> :developerId)) AS displayableEandOs group by round(location.STX * :coordinateMultiplier,-4), round(location.STY * :coordinateMultiplier, -4)",
            nativeQuery = true)
    Set<Cluster> getClustersForSpecificDeveloper(double bottomLeftCornerX, double bottomLeftCornerY, double topRightCornerX, double topRightCornerY, double coordinateMultiplier, String developerId);
}

Note that we had to use a Profile at the interface level because it was not possible to find queries working in both
Microsoft SQL Server and H2/H2GIS. Among other things, spatial functions are different. In Microsoft SQL Server, we use
 ConvexHullAggregate. In H2GIS, it does not exist and its equivalent is ST_ConvexHull.

Note how the mapping to a non-entity bean is done: we return a set of Cluster where
public interface Cluster {
    Long getNumberOfIssues();
    String getCentre();
    String getErrorRefs();
    Long getNumberOfIssuesOwnedByMe();
}

Note how the :: in front of ConvexHullAggregate is escaped with \\.

Note how columns are given aliases. Without these, you get runtime exceptions.


- To be able to use the H2 console:
When developing a Spring Boot app using a database, it may be useful to point to a H2 DB during development and to send
SQL queries to it. To achieve this, you can enable the H2 console by doing the following.

Add the dependencies (if you need both H2 & H2GIS):
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>${h2.version}</version>
    <scope>runtime</scope>
</dependency>
<!-- https://mvnrepository.com/artifact/org.orbisgis/h2gis -->
<dependency>
    <groupId>org.orbisgis</groupId>
    <artifactId>h2gis</artifactId>
    <version>${h2.gis.version}</version>
    <exclusions>
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.locationtech.jts</groupId>
            <artifactId>jts-core</artifactId>
        </exclusion>
    </exclusions>
    <scope>runtime</scope>
</dependency>

Create a file called application-h2.properties with:
spring.jpa.properties.hibernate.dialect=org.hibernate.spatial.dialect.h2geodb.GeoDBDialect

spring.datasource.url=jdbc:h2:mem:eando
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password

spring.h2.console.enabled=true

If you have Spring security enabled, you will also need to add the lines:
http.headers().frameOptions().disable();
and
http.csrf().disable()
and
http.authorizeRequests(authorize -> {
            authorize.antMatchers("/api-docs/**", "/swagger-ui.html", "/swagger-ui/**", "/h2-console/**").anonymous();

in your class:

@EnableWebSecurity
public class RoleBasedAdapter extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) throws Exception {
    ...

Then, after having started the app, go to http://localhost:8081/h2-console if your app runs on 8081. Fill in the details
as per details entered in application-h2.properties. You should be able to connect to the DB and send SQL queries to it.


- @DataJpaTest failing with java.lang.IllegalStateException: Failed to load ApplicationContext
    - Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.sample.appinsights.TelemetryEventLogger' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
    - solution: annotate the test class with @org.springframework.context.annotation.Import(TelemetryEventLogger.class)
     
